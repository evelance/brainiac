//! # Brainfuck parser
//! Parses Brainfuck source string into a sequence of instructions.
//! Can optionally apply optimizations to the generated bytecode.

const std = @import("std");
const Optimizer = @import("Optimizer.zig");
const Instruction = @import("Opcode.zig").Instruction;

allocator: std.mem.Allocator,
/// Parsed instruction sequence
program: std.ArrayList(Instruction),
/// Number of unpaired (open) brackets
jump_balance: usize,
/// Largest offset for memory read or write relative to current
/// cell in either direction to adjust memory danger zone size.
max_off: usize,

pub const ParseError = error {
    UnmatchedJumpBack,      // Only possible syntax error
    UnmatchedJumpForward,   // Program incomplete?
};

pub fn init(allocator: std.mem.Allocator) !@This() {
    return .{
        .allocator = allocator,
        .program = std.ArrayList(Instruction).init(allocator),
        .jump_balance = 0,
        .max_off = 0,
    };
}

pub fn deinit(self: *@This()) void {
    self.program.deinit();
}

/// Simple translation of source code into equivalent instructions.
pub fn parse(self: *@This(), source: []const u8) !void {
    for (source) |c| {
        switch (c) {
            '+' => try self.program.append(.{ .off = 0, .op = .{ .add  =  1 }}),
            '-' => try self.program.append(.{ .off = 0, .op = .{ .add  = -1 }}),
            '>' => try self.program.append(.{ .off = 0, .op = .{ .move =  1 }}),
            '<' => try self.program.append(.{ .off = 0, .op = .{ .move = -1 }}),
            '.' => try self.program.append(.{ .off = 0, .op = .print }),
            ',' => try self.program.append(.{ .off = 0, .op = .read }),
            '[' => {
                self.jump_balance += 1;
                try self.program.append(.{ .off = 0, .op = .{ .jump_forward = 0 }});
            },
            ']' => {
                if (self.jump_balance == 0)
                    return ParseError.UnmatchedJumpBack;
                self.jump_balance -= 1;
                try self.program.append(.{ .off = 0, .op = .{ .jump_back = 0 }});
            },
            else => {}, // Ignore all other characters (they are comments)
        }
    }
    if (self.jump_balance > 0)
        return ParseError.UnmatchedJumpForward;
}

/// Apply optimization substitutions to internal program
pub fn optimize(self: *@This(), optimization_level: u8, verbose: bool) !void {
    var optimized = std.ArrayList(Instruction).init(self.allocator);
    defer optimized.deinit();
    
    try Optimizer.optimize(self.allocator, optimization_level, verbose, &self.program, &optimized);
    
    // Use the optimized program
    self.program.clearAndFree();
    try self.program.appendSlice(optimized.items);
}

/// Calculate and write jump addresses and max move.
/// Turn parsed instruction list into allocated slice.
/// The caller is responsible for freeing it.
pub fn finalize(self: *@This()) ![]Instruction {
    // Stack with addresses of unpatched forward jumps.
    var jumps = std.ArrayList(usize).init(self.allocator);
    defer jumps.deinit();
    for (self.program.items, 0..) |instruction, addr| {
        switch (instruction.op) {
            .jump_forward => {
                try jumps.append(addr);
            },
            .jump_back => {
                const back_addr = jumps.getLast(); _ = jumps.pop(); // Hack to make it work on Zig 0.13 and Zig 0.15
                self.program.items[back_addr].op.jump_forward = addr;
                self.program.items[addr].op.jump_back = back_addr;
            },
            else => {},
        }
    }
    std.debug.assert(jumps.items.len == 0);
    self.jump_balance = 0;
    self.calculateMaxOffset();
    return self.program.toOwnedSlice();
}

/// Calculate maximal offset of memory accesses relative to current
/// cell to ensure that the memory danger zone cannot get skipped.
fn calculateMaxOffset(self: *@This()) void {
    // Accumulate multiple sequential moves. Every operation except
    // move does either a read or a write access and will therefore
    // reset the accumulated offset.
    self.max_off = 0;
    var extra_off: isize = 0;
    for (self.program.items) |instruction| {
        self.max_off = @max(self.max_off, @abs(instruction.off + extra_off));
        switch (instruction.op) {
            .move => |val| {
                extra_off += val;
            },
            .mac => |op| {
                self.max_off = @max(self.max_off, @abs(op.offset + extra_off));
                extra_off = 0;
            },
            else => {
                extra_off = 0;
            },
        }
    }
    self.max_off = @max(self.max_off, @abs(extra_off));
}
